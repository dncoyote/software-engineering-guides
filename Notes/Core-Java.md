# **Core Java**
## Table of Contents

 1. [Internal Concepts](#Internal-Concepts)
    1. [JRE, JVM, JDK](#JRE,-JVM,-JDK)
    2. [JAR Files](#JRE,-JVM,-JDK)
    3. Compilation and Bytecode
    4. Memory Management
    5. Class Loading
    6. Garbage Collection
    7. Heap and Stack
    8. Just-In-Time Compilation (JIT)
    9. Java Process and Runtime
 2. [Language Basics](#language-basics)
    - Variables and Data Types
    - Arrays
    - Operators
    - Control Flow
    - Methods and Functions
    - Strings
    - Packages
    - Native Methods
 3. [Classes](#classes)
    - Class Basics
    - Attributes and Fields
    - Methods
    - Constructors
    - Access Modifiers
    - Nested classes
    - Static
    - Class modifiers
    - Wrapper Classes
    - Autoboxing
    - Object Class
    - Instanceof keyword
 4. [Inheritance](#Inheritance)
    - Subclasses
    - Accessing Superclass Members
    - Method Overriding
    - Super Keyword
 5. [Interfaces](#Interfaces)
    - Basics
    - Creating Interfaces
    - Implementing and Extending Interfaces 
    - Multiple Inheritance with Interfaces
    - Static Methods in Interfaces
    - Choosing between Interfaces and Abstract Classes
    - Nested Interfaces
    - Variables in Interfaces
    - Sealed interfaces
6. [Enumerations](#Enumerations)
    - Declaring Enums
    - Enum Constants
    - Enum Constructors
    - Enum Methods and Fields
    - Enum Methods and Values
        - name()
        - ordinal()
        - valueOf()
7. [Exception Handling](#Enumerations)        
    - Understanding Exceptions
    - Types of Exceptions 
    - Exception Hierarchy
    - try-catch Blocks
    - Multiple catch Blocks
    - Finally Block 
    - Throwing Exceptions
    - Checked vs. Unchecked Exceptions
    - Custom Exceptions
    - Using try-with-resources
    - Exception Propagation 
    - Exception Chaining 
    - Handling Uncaught Exceptions
8. [Collections](#Enumerations)  
    - Collection Interfaces
    - Collection Classes
    - Selecting the right collection class  
9. [Generics](#Enumerations)  
    - Basics 
    - Type Parameters and Type Arguments
    - Generic Classes
    - Generic Methods
    - Wildcards
    - Generic Interfaces
10. [Annotations](#Enumerations)
    - Fundamentals
        - @Override
        - @SuppressWarnings
        - @Deprecated
        - @@SafeVarargs
        - @FunctionalInterface
        - @Native
        - @Target
        - @Retention
        - @Inherited
        - @Documented
        - @Repeatable 
    - Creating custom Annotations
11. [Lambda Expressions](#Enumerations)
    - Fundamentals
12. [Java I/O](#Enumerations)
    - Understanding I/O Streams
    - Byte Streams vs. Character Streams
    - File I/O 
    - Buffered Streams
    - Standard Streams
    - Reading and Writing Files
    - Map and reduce
    - Interfaces
    - Serialization
    - Java NIO
13. [Multithreaded Programming](#Enumerations)
    - Basics
    - Thread Creation
    - Synchronization
    - Executor Framework
    - Callable and Future
    - Thread Communication
    - Thread States
    - Deadlocks and Livelocks
    - Concurrency Utilities
    - Atomic Classes
    - Thread Pools
    - Parallel Streams
14. [Database](#Enumerations)
    - JDBC
    - CRUD
15. [JVM Options](#Enumerations)
    - Standard Options
    - Memory Management
    - Thread Management
    - Performance Tuning
    - GC Tuning
    - Profiling and Debugging
16. [Misc](#Enumerations)
    - Date and Time APIs 
    - JPA
    - Hibernate
    - Encoding and Decoding
    - Encryption and Decryption
    - Regex
    - Reflection

# **Internal Concepts**
## JVM
- Java Virtual Machine is an abstract machine that runs Java bytecode. It is the “engine” that executes Java programs.
- JVM implementations (like HotSpot, OpenJ9, GraalVM) define performance characteristics, garbage collection, and optimization strategies—critical for production systems.
- Reads .class files (bytecode) generated by the compiler.
- Handles memory (heap, stack, method area, garbage collection).
- Performs JIT (Just-In-Time) compilation to native machine code for speed.
- Provides platform independence: “Write once, run anywhere."
## JRE
- Java Runtime Environment is a package containing the JVM + core libraries + supporting files needed to run Java applications
- You need JRE (JVM + core java libraries `java.lang`, `java.util`) when you run a Java Program.
- Does not include development tools like the compiler.
- Used mainly to execute Java apps.
## JDK
- Java Development Kit is a superset of JRE that includes tools for developers (compiler javac, debugger, profilers, etc.) to build and run Java applications. 
- You need JDK (compiler + tools + JRE) when you develop Java Programs.
- Contains development tools:
    - javac (Java compiler)
    - javadoc (documentation generator)
    - jdb (debugger)
    - javap (class disassembler)
    - Packaging/signing tools (jar, jarsigner).
- Used for developing + running Java apps.
- From Java 9+, JRE distribution is no longer shipped separately. Only JDK distributions are available; the runtime is part of the JDK.
- For production deployments, many teams use jlink to create custom smaller runtimes.
### Compilation and Execution Flow
- First we code.
 
```java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, Java!");
    }
}
```
- Compile with JDK
    - `javac` (from JDK) converts `.java` → `.class` (bytecode).
```
javac HelloWorld.java
```

- Run with JVM (via JRE)
    - `java` command launches the JVM.
    - JVM loads `HelloWorld.class`, verifies bytecode, JIT-compiles, and executes.
```
java HelloWorld
```
## JAR Files
- A JAR (Java ARchive) file is a compressed package (based on the ZIP format) that bundles together.
    - `.class` files (compiled Java bytecode)
    - resources (images, property files, config files, etc.)
    - metadata (like `MANIFEST.MF`)
- It makes distributing and running Java applications or libraries easier.    
    - Convenience: Instead of shipping 50 `.class` files, you ship one `.jar`.
    - Reusability: JARs act as libraries other projects can import.
    - Execution: With the right metadata, JARs can be made executable (like `.exe`or `.sh`).
    - Ecosystem: All dependency management systems (Maven, Gradle) ultimately resolve dependencies into JARs.
- JAR &rarr; General-purpose library or app (desktop, CLI, etc.).
### Workflow
- First we code.
```java
package com.example;

public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello from JAR!");
    }
}
```
- Compile
```
javac com/example/HelloWorld.java
```
- Package to JAR
```
jar cfm HelloWorld.jar manifest.txt com/example/*.class
```
- Run 
```
java -jar HelloWorld.jar
```
```
Hello from JAR!
```
## WAR Files
- A WAR (Web Application Archive) is a package file (also ZIP-based, like JAR) used to bundle a Java web application.
- It contains:
    - Java classes (`.class` or `.jar`)
    - Web resources (HTML, JSP, CSS, JavaScript, images)
    - Configuration files (`web.xml`, annotations, Spring configs, etc.)
- WARs are deployable units inside web/application servers.
- WARs &rarr; Specifically for web apps (HTTP endpoints, servlets, JSPs).
- Spring Boot often builds a fat JAR (with embedded Tomcat/Jetty). So you don’t need WAR + external Tomcat—you just run: `java -jar MyApp.jar`.
- But Spring Boot can still produce a WAR if you want to deploy to an external server.

## Compilation and Bytecode
### Compilation
- The process of converting human-readable `.java` source code into `.class` files containing bytecode.
- Java uses a hybrid model of both Compilation and Interpretation.
    - Compile once → bytecode.
    - Run → JVM interprets bytecode.
    - Hot code paths → JIT compiles to native machine code for speed.
- So Java has portability (bytecode) + performance (JIT native compilation).

### Bytecode
- A platform-independent, intermediate representation of your program—stored as instructions for the Java Virtual Machine (JVM).
- Platform independent: Same `.class` runs on Windows, Linux, Mac (as long as JVM exists).
- Low-level instructions: Similar to assembly, but for a virtual machine.
- Compact: Uses an efficient binary format.
- Verified: JVM checks bytecode (security, type safety, memory safety) before execution.

## Memory Management
- Memory management in Java is how the JVM allocates, uses, and reclaims memory for objects and program execution.
- Unlike C/C++, Java automates memory management with Garbage Collection (GC)—you don’t explicitly `free()` memory.
- This prevents memory leaks, improve performance by eliminating `OutOfMemoryError`, GC pauses and help write scalable systems.
- Objects with no live references → eligible for GC.
#### Java Memory model
- When we run a Java program, JVM divides memory into different runtime areas:
##### Heap (biggest area)
- Stores all objects created with new.
- Shared by all threads.
- Divided into generations (Young, Old).
- Garbage Collector runs here.
##### Stack (per thread)
- Stores local variables, method call frames, and references.
- Each thread gets its own stack.
- Operates LIFO (Last-In, First-Out).
- Automatic cleanup when method exits.
##### Method Area (a.k.a. Metaspace in Java 8+)
- Stores class metadata (class names, methods, fields, bytecode).
- Also stores static variables.
- Since Java 8 → stored in native memory, not heap.
##### Program Counter (PC) Register
- Small per-thread register holding the address of the current instruction.
##### Native Method Stack
- Used for executing native code (via JNI, e.g., C/C++ libraries).

## Garbage Collection
- Garbage Collection (GC) is the JVM’s automatic process of reclaiming memory by removing objects that are no longer reachable by any live reference in a running program.
- In simple words: it frees memory from unused objects so you don’t have to call free() like in C/C++.
- This prevents memory leaks, improve performance by eliminating `OutOfMemoryError`, GC pauses and help write scalable systems.
- GC can be called using `System.gc()`: Only a suggestion. JVM may ignore it. 
- `finalize()`: Deprecated in Java 9. Unpredictable; use try-with-resources or Cleaner.
- GC manages
    - Heap only (Young Generation + Old Generation).
    - Metaspace (class metadata) is also GC-managed, but differently.
    - Stack cleanup is automatic when methods return.
### Phases in Garbage Collection
- Mark : During this phase, the garbage collector traverses all objects in the heap and marks those that are still in use. It typically starts with the root objects (objects directly accessible by the program) and recursively marks all reachable objects.
- Sweep : In this phase, the garbage collector scans the entire heap and reclaims memory occupied by unmarked (unreachable) objects. These unmarked objects are considered garbage and are removed from memory.
- Compact : In this phase, the garbage collector compacts the memory by moving all live (marked) objects to one contiguous block of memory, eliminating or reducing fragmentation. 
### Generational GC model
- Young Generation
    - Eden space: where new objects start.
    - Survivor spaces (S0, S1): objects surviving GC cycles.
    - Collection here = Minor GC (fast).
- Old (Tenured) Generation
    - Long-lived objects promoted here.
    - Collection here = Major GC / Full GC (slower, can pause app).
- Metaspace (Java 8+)
    - Stores class metadata.
    - Managed separately from heap, but also GC’d.

## Heap Memory
- Runtime memory where all objects (created with new) are stored. Shared across all threads. Managed by Garbage Collector (GC).
- It plays a vital role in Performance tuning, OutOfMemoryErrors, GC behavior.
#### Characteristics
- It stores
    - Objects (`new Person()`)
    - Instance Variables
    - Arrays
- Heap Memory is shared among all threads.
- Memory management is automatic and performed by GC.
- Heap Objects live until no references exists.
- String literals → stored in a special area of heap called the string pool, but referenced from stack.
- Heap Access slower.
## Stack Memory
- Per-thread memory that stores method calls, local variables, and references. Follows LIFO (Last-In-First-Out) order. Freed automatically when methods return.
- It plays a vital role in Recursion depth, StackOverflowErrors, thread safety

#### Characteristics
- It stores
    - Method call frames.
    - Local primitive variables (`int x = 5`).
    - References to objects in heap (`Person p = new Person();`).
- Each thread has its own stack.
- Stack variables are freed automatically when method exits.
- Stack access is faster (LIFO).
 
```java
public class HeapStackDemo {
    public static void main(String[] args) {
        int x = 42;                      // primitive → stack
        String name = new String("Ali"); // reference → stack, object → heap
        Person p = new Person("Sara");   // reference → stack, Person → heap
        p = null; // heap object now eligible for GC if no other references
    }
}

class Person {
    String name;
    Person(String name) {
        this.name = name;
    }
}
```
## Class Loading
- Class loading is the process by which the JVM locates, loads, and prepares classes (`.class` bytecode files) into memory so they can be used at runtime.
- It is handled by ClassLoaders that are special Java objects that follow a parent delegation model.
- A class is loaded once per ClassLoader. Two ClassLoaders can load the same `.class` into different copies.
- Static blocks run only once per class (per ClassLoader).
- Errors:
    - `ClassNotFoundException` → when code explicitly tries to load a class (e.g., `Class.forName`) but file not found.
    - `NoClassDefFoundError` → class was present during compilation but missing at runtime.
#### Phases of Class Loading
- Loading
    - ClassLoader finds the `.class` file (from disk, JAR, network, etc.).
    - Bytecode is read into memory as a Class object.
- Linking
    - Verification: Bytecode checked for correctness & security (no illegal casts, stack overflows).
    - Preparation: Memory allocated for static variables (default values assigned).
    - Resolution: Symbolic references (method/field names) replaced with direct references.
- Initialization
    - Static initializers and static blocks executed.
    - Final values assigned to static variables.
    - Happens lazily, i.e., only when class is first used.
#### ClassLoader Hierarchy
- Bootstrap ClassLoader
    - Part of JVM (native).
    - Loads core Java classes (`java.lang`, `java.util`, etc.) from `$JAVA_HOME/jre/lib`.
    - Not a Java object, written in C/C++.
- Extension (Platform) ClassLoader
    - Loads classes from `jre/lib/ext` or `java.ext.dirs`.
- Application (System) ClassLoader
    - Loads classes from the classpath (`-cp`, `CLASSPATH`, project `bin/`, etc.).
    - Loads user-defined classes.
- Custom ClassLoaders
    - You can extend ClassLoader to load classes from network, DB, or encrypted files.
    - Used by frameworks.

```java
public class LoaderDemo {
    static {
        System.out.println("Class Loaded!");
    }

    public static void main(String[] args) throws Exception {
        System.out.println("Main started");
        Class.forName("LoaderDemo"); // triggers class loading
    }
}
```
```
Main started
Class Loaded!
```

## JIT Compilation
- JIT (Just-In-Time) Compilation is a JVM feature where bytecode (platform-independent instructions in `.class` files) is compiled into native machine code while the program is running, so that the CPU can execute it directly.
- It’s called “just-in-time” because the compilation happens at runtime, only for code that is actually executed.
#### Characteristics
##### Execution paths
- Interpretation
    - JVM reads bytecode line by line and executes.
    - Slow, but no compilation overhead.
- JIT Compilation
    - Hot methods/loops are detected → compiled to native code.
    - Future calls execute machine code directly (super fast).
##### Importance
- Portability + performance: Java is compiled once to bytecode (portable), then JIT-compiled to native code (fast).
- Adaptive optimization: JVM identifies “hot code” (methods/loops executed many times) and optimizes them aggressively.
- Makes Java almost as fast as C++ in long-running applications (servers, games, big data systems).
##### JIT optimizations
JIT is not a simple compiler — it does runtime optimizations based on actual program behavior:
- Method inlining
    - Small frequently called methods are “inlined” (code inserted directly, avoiding function call overhead).
- Dead code elimination
    - Removes unused or unreachable code paths.
- Loop unrolling
    - Expands loops for speed.
- Escape analysis
    - Detects if an object never “escapes” a method → allocates it on stack instead of heap (avoiding GC pressure).
- Speculative optimizations
    - If JIT notices a branch always takes one path, it optimizes for that. If assumption breaks → JVM deoptimizes and falls back. 
##### Types 
- C1 (Client Compiler) → fast compilation, basic optimizations. Good for short-lived apps (GUIs, tools).
- C2 (Server Compiler) → slower compilation, aggressive optimizations. Good for long-running apps (servers).
- Tiered Compilation (default) → combines C1 + C2

## Java Process and Runtime 
- A Java process is the operating system process created when you run a Java program (via the `java` command).
- The Java Runtime (JRE) provides the environment inside which this process executes — JVM, core libraries, memory, GC, etc.
- When `java HelloWorld` is executed : OS runs a process → process runs a JVM instance → JVM executes your bytecode.
#### Lifecycle of a Java Process
- Program Launch  
    - When `java HelloWorld` is executed : OS runs a process → process runs a JVM instance → JVM executes your bytecode.
- JVM Startup
    - Initializes memory (heap, stack, metaspace).
    - Loads `java.lang.Object`, `System`, and other core classes.
    - Sets up bootstrap class loader, thread system, GC.
- Class Loading
    - `HelloWorld.class` is loaded via ClassLoader.
    - Bytecode verified, prepared, initialized.
- Execution
    - JVM invokes `public static void main(String[] args)`.
    - Bytecode executed (interpreted → JIT compiled).
    - Program uses heap, stack, GC, threads, I/O.
- Shutdown
    - When `main()` finishes (or `System.exit()` is called).
    - JVM runs shutdown hooks, finalizes threads, frees resources.
    - OS destroys the process.

# **Language Basics**
## Variables
 - A variable is a container for storing data values.
 - Each variable has a name, type and value.
```java
int age = 31; 
```
### Types of Variables
#### Local Variables 
- Declared inside methods, constructors, or blocks. They are accessible only within the scope where they are defined.
```java
public void display() {
    int localVar = 10; // Local variable
    System.out.println(localVar);
}
```
#### Instance Variables 
- Declared outside methods but inside a class. They belong to an instance of the class.
```java
public class MyClass {
    int instanceVar = 20; // Instance variable
}
```

#### Static Variables
- Declared with the `static` keyword and shared among all instances of the class.
```java
public class MyClass {
    static int staticVar = 30; // Static variable
}
```
### Literals
- Literals are constant values directly assigned to variables. They represent fixed values in the source code.

### Type Conversion
- Type Conversion is the process of converting a value from one data type to another.
#### Implicit Type Conversion
- Automatically performed by Java when converting a smaller data type to a larger one
```java
int num = 10;
double result = num; // int to double
System.out.println("Result: " + result);
```
> Conversion Order - byte -> short -> int -> long -> float -> double
#### Explicit Type Conversion
- Manually performed to convert a larger data type to a smaller one.
- Can lead to data loss or truncation.
```java
 double num = 10.99;
 int result = (int) num; // double to int
 System.out.println("Result: " + result);
```

### Type Casting
- Casting refers to explicitly converting a value from one data type to another. It is performed using parentheses ().
- Casting is used when working with generics
- Used for object hierarchy conversions or narrowing primitives.
```java
Object obj = "Hello";
String str = (String) obj; // Explicit casting
```

## Data Types
- Data types define the type of data a variable can hold.
- In Java, Data Types are broadly categorized into Primitive Data Types and Non-Primitive Data Types.
### Primitive Data Types
- Java provides 8 built-in data types

| Data Type      |Description      | Size      |Range      |Example      |
| :---  | :---   |:---         |:---           |:---          |
| `byte` | Integer (small range) | 1 byte |-128 to 127 |`byte b = 100;` |
| `short` | Integer (medium range) | 2 bytes |-32,768 to 32,767 |`short s = 32000;` |
| `int` | Integer (default) | 4 bytes |-2^31 to 2^31 - 1 |`int i = 123456789;` |
| `long` | Integer (large range) | 8 bytes |-2^63 to 2^63 - 1 |`long l = 9223372036854775807L;` |
| `float` | Decimal (single precision) | 4 bytes |3.4028235E38 to ~1.4E-45 |`float f = 3.14F;` |
| `double` | Decimal (double precision) | 8 bytes |1.7976931348623157E308 to ~4.9E-324 |`double d = 3.141592653589793;` |
| `char` | Single character | 2 bytes |0 to 65,535 (Unicode character set) |`char c = 'A';` |
| `boolean` | True or False | 1 bit |true, false |`boolean isJavaFun = true;` |

### Non-Primitive Data Types | Reference Types
- Non-primitive data types include Objects, Strings, Arrays, Enums and Classes. 
- They are also called as  Reference Types.
- These types refer to objects and hold the memory address (or reference) of the object rather than the actual data. In contrast to primitive types, which store the actual value, reference types store the memory address where the object data is stored.
- Default value is `null`.
- The reference variable itself is on the stack, but the object it refers to is stored in the heap.

## `var` keyword | Local Variable Type Inference
- Local Variable Type Inference is a feature introduced in Java 10, 
- This allows the compiler to infer the type of a local variable from the context without explicitly specifying the type. 
- This is done using the `var` keyword.
- `var` keyword can only be used for local variables inside methods, loops, and other local scopes. It cannot be used for instance variables, method parameters, or return types.
```java
var greeting = "Hello, World!"; // Java will infer the type as String
var num = 10;  // Java infers the type as int
var price = 99.99;  // Java infers the type as double

//Collection
var list = new ArrayList<String>();  // Java infers the type as ArrayList<String>
list.add("Hello");
list.add("World");

//loop
var arr = new int[]{1, 2, 3, 4, 5};
for (var num : arr) {  // Java infers the type of num as int
    System.out.println(num);
}
```

## Arrays
- An array is a container object that holds a fixed number of values of a single type
- Java arrays are objects, and they store multiple values, either primitive or reference types, in a contiguous block of memory.
- Once an array is created, its size cannot be changed.
- The elements in an array are stored in consecutive memory locations.
- Array elements are accessed by their index, starting from 0.

### Single-Dimensional Arrays
```java
int[] numbers = {1, 2, 3, 4, 5}; // Array of integers
String[] names = {"Alice", "Bob", "Charlie"}; // Array of strings
```

### Multi-Dimensional Arrays
```java
int[][] matrix = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};
int[][] matrix = new int[3][3]; // 2D array with 3 rows and 3 columns

```

### Arrays of Objects
- Java arrays can store objects as well as primitive data types. 
- When you create an array of objects, each element in the array holds a reference to an object.
```java
// Array of String Objects
String[] fruits = new String[3];  // Declare an array of 3 String objects
fruits[0] = "Apple";  // Assign values to the array
fruits[1] = "Banana";
fruits[2] = "Orange";

// Array of custom Objects
Person[] people = new Person[2];
people[0] = new Person("Alice", 25);
people[1] = new Person("Bob", 30);
```
## Operators
- Operators are used to manipulate data and variables in Java.
    - Arithmetic Operators
    - Relational Operators
    - Logical Operators
    - Bitwise Operators
    - Assignment Operators
    - Unary Operators
    - Ternary (Conditional) Operator
    - Instanceof Operator
### Bitwise Operators
- Bitwise operators are used to perform bit-level operations on integer types (byte, short, int, long).
```java
int a = 5;  // Binary: 0101
int b = 3;  // Binary: 0011

System.out.println("a & b: " + (a & b)); // 1 (Binary: 0001)
System.out.println("a | b: " + (a | b)); // 7 (Binary: 0111)
System.out.println("a ^ b: " + (a ^ b)); // 6 (Binary: 0110)
System.out.println("~a: " + (~a));       // -6 (Binary: 1010, Two's complement)
System.out.println("a << 1: " + (a << 1)); // 10 (Binary: 1010)
System.out.println("a >> 1: " + (a >> 1)); // 2 (Binary: 0010)
```

### Ternary Operators
- The ternary operator is a shorthand for the if-else statement. 
- It takes three operands: a condition, a value for true, and a value for false.
```java
int a = 10;
int b = 5;
int result = (a > b) ? a : b;
System.out.println("Max value: " + result); // 10
```

## Control Flow
- Control flow refers to the order in which individual statements, instructions, or function calls are executed or evaluated in a program

### Decision Making Statements
#### `if - else` Statement
- Executes a block of code if the condition is true.
```java
if (marks >= 90) {
    System.out.println("Grade: A");
} else if (marks >= 75) {
    System.out.println("Grade: B");
} else if (marks >= 50) {
    System.out.println("Grade: C");
} else {
    System.out.println("Grade: Fail");
}
```

#### `switch` Statement
- Executes one block of code among many based on a matching case.
```java
int day = 3;
switch (day) {
    case 1:
        System.out.println("Monday");
        break;
    case 2:
        System.out.println("Tuesday");
        break;
    case 3:
        System.out.println("Wednesday");
        break;
    default:
        System.out.println("Other day");
}
```
### Looping Statements

#### `for` loop
- Executes a block of code for a specific number of iterations.
```java
for (int i = 1; i <= 5; i++) {
    System.out.println("Count: " + i);
}
```
#### `while` loop
- Executes a block of code while the condition is true.
```java
 int i = 1;
 while (i <= 5) {
    System.out.println("Count: " + i);
    i++;
}
```
#### `do-while` loop
- Executes a block of code at least once, then repeats while the condition is true.
```java
int i = 1;
do {
    System.out.println("Count: " + i);
    i++;
} while (i <= 5);
```
#### `enhanced for` loop
```java
for (int num : numbers) {
    System.out.println("Number: " + num);
}
```
### Branching Statements
- Branching statements are used to transfer control to another part of the program.

#### `break` Statement
- Terminates the loop or switch statement.
```java
for (int i = 1; i <= 10; i++) {
    if (i == 5) break; // Exit the loop when i is 5
    System.out.println(i);
}
```
#### `continue` Statement
- Skips the current iteration of the loop and moves to the next.
```java
for (int i = 1; i <= 10; i++) {
    if (i % 2 == 0) continue; // Skip even numbers
    System.out.println(i);
}
```
#### `return` Statement
- Exits from the current method and optionally returns a value.
```java
return a + b;
```

## Methods and Functions
In Java, methods (also called functions in other languages) are blocks of code that perform a specific task.
### Defining and Calling Methods
#### Syntax
```
access_modifier return_type method_name(parameters) {
    // Method body (code logic)
    return value; // Only if return type is not void
}
```
### Method Parameters
- Methods can take parameters (inputs) to work with dynamic values.
```java
 public static int addNumbers(int a, int b) {
        return a + b;
    }
```
### Method Overloading
- Method Overloading allows multiple methods with the same name but different parameters.
```java
public class OverloadExample {
    // Method with two integers
    public static int multiply(int a, int b) {
        return a * b;
    }

    // Overloaded method with three integers
    public static int multiply(int a, int b, int c) {
        return a * b * c;
    }

    // Overloaded method with doubles
    public static double multiply(double a, double b) {
        return a * b;
    }

    public static void main(String[] args) {
        System.out.println(multiply(2, 3));      // Calls first method
        System.out.println(multiply(2, 3, 4));   // Calls second method
        System.out.println(multiply(2.5, 3.5));  // Calls third method
    }
}
```
## Strings
- In Java, strings are objects that represent a sequence of characters. 
- Unlike primitive types, strings are immutable, meaning their values cannot be changed once created.
### Declaring and Initializing Strings
#### String Literal
```java
String name = "Java";  // Stored in the String Pool
```
- Efficient, as JVM reuses existing strings in the String Pool.

#### `new` keyword
```java
String name = new String("Java"); // Creates a new object in heap
```
- Avoid this approach unless needed, as it creates a new object every time.

### String Immutability
- Prevents modification of sensitive data.
- Helps JVM optimize memory with the String Pool.
- Since strings don’t change, they can be safely shared across threads.

```java
public class StringExample {
    public static void main(String[] args) {
        String s1 = "Hello";
        s1 = s1 + " World"; // Creates a new String object
        
        System.out.println(s1); // Output: Hello World
    }
}
```
## Packages
## Native Methods
